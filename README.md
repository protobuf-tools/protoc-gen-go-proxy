# protoc-gen-grpcproxy

protoc-gen-grpcproxy generates RPC proxy for .pb.go service types.

## Example

### echo

```proto
syntax = "proto3";

package echo.v1;

option go_package = "github.com/protobuf-tools/protoc-gen-grpcproxy/testdata/v1/echo";

service Echo {
  rpc Say(SayRequest) returns (SayResponse) {};
}

// SayRequest request of Say.
message SayRequest {
  // The ID of the request message.
  string message_id = 1;

  // The body of the request message.
  string message_body = 2;
}

// SayResponse response of Say.
message SayResponse {
  // The ID of the response message.
  string message_id = 1;

  // The body of the response message.
  string message_body = 2;
}

```

to

```go
// Code generated by protoc-gen-grpcproxy. DO NOT EDIT.

package echo

import (
	context "context"
	errors "errors"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	net "net"
)

var _ emptypb.Empty

// Proxy allows to create Echo proxy servers.
type Proxy struct {
	Say func(ctx context.Context, req *SayRequest) (*SayResponse, error)
}

// Serve starts serving the proxy server on the given listener with the specified options.
func (p *Proxy) Serve(l net.Listener, opts ...grpc.ServerOption) error {
	srv := grpc.NewServer(opts...)
	RegisterEchoServer(srv, &echoServer{proxy: p})

	return srv.Serve(l)
}

var errNotSupported = errors.New("operation not supported")

type echoServer struct {
	proxy *Proxy
}

func (s *echoServer) Say(ctx context.Context, req *SayRequest) (*SayResponse, error) {
	fn := s.proxy.Say
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}
```

### Spanner

```proto
syntax = "proto3";

package google.spanner.v1;

// omit ...

// Cloud Spanner API
//
// The Cloud Spanner API can be used to manage sessions and execute
// transactions on data stored in Cloud Spanner databases.
service Spanner {
  option (google.api.default_host) = "spanner.googleapis.com";
  option (google.api.oauth_scopes) =
      "https://www.googleapis.com/auth/cloud-platform,"
      "https://www.googleapis.com/auth/spanner.data";

  // omit...
  rpc CreateSession(CreateSessionRequest) returns (Session) {
    option (google.api.http) = {
      post: "/v1/{database=projects/*/instances/*/databases/*}/sessions"
      body: "*"
    };
    option (google.api.method_signature) = "database";
  }

  // omit...
  rpc BatchCreateSessions(BatchCreateSessionsRequest) returns (BatchCreateSessionsResponse) {
    option (google.api.http) = {
      post: "/v1/{database=projects/*/instances/*/databases/*}/sessions:batchCreate"
      body: "*"
    };
    option (google.api.method_signature) = "database,session_count";
  }

  // omit...
  rpc GetSession(GetSessionRequest) returns (Session) {
    option (google.api.http) = {
      get: "/v1/{name=projects/*/instances/*/databases/*/sessions/*}"
    };
    option (google.api.method_signature) = "name";
  }

  // omit...
  rpc ListSessions(ListSessionsRequest) returns (ListSessionsResponse) {
    option (google.api.http) = {
      get: "/v1/{database=projects/*/instances/*/databases/*}/sessions"
    };
    option (google.api.method_signature) = "database";
  }

  // omit...
  rpc DeleteSession(DeleteSessionRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      delete: "/v1/{name=projects/*/instances/*/databases/*/sessions/*}"
    };
    option (google.api.method_signature) = "name";
  }

  // omit...
  rpc ExecuteSql(ExecuteSqlRequest) returns (ResultSet) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:executeSql"
      body: "*"
    };
  }

  // omit...
  rpc ExecuteStreamingSql(ExecuteSqlRequest) returns (stream PartialResultSet) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:executeStreamingSql"
      body: "*"
    };
  }

  // omit...
  rpc ExecuteBatchDml(ExecuteBatchDmlRequest) returns (ExecuteBatchDmlResponse) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:executeBatchDml"
      body: "*"
    };
  }

  // omit...
  rpc Read(ReadRequest) returns (ResultSet) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:read"
      body: "*"
    };
  }

  // omit...
  rpc StreamingRead(ReadRequest) returns (stream PartialResultSet) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:streamingRead"
      body: "*"
    };
  }

  // omit...
  rpc BeginTransaction(BeginTransactionRequest) returns (Transaction) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:beginTransaction"
      body: "*"
    };
    option (google.api.method_signature) = "session,options";
  }

  // omit...
  rpc Commit(CommitRequest) returns (CommitResponse) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:commit"
      body: "*"
    };
    option (google.api.method_signature) = "session,transaction_id,mutations";
    option (google.api.method_signature) = "session,single_use_transaction,mutations";
  }

  // omit...
  rpc Rollback(RollbackRequest) returns (google.protobuf.Empty) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:rollback"
      body: "*"
    };
    option (google.api.method_signature) = "session,transaction_id";
  }

  // omit...
  rpc PartitionQuery(PartitionQueryRequest) returns (PartitionResponse) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:partitionQuery"
      body: "*"
    };
  }

  // omit...
  rpc PartitionRead(PartitionReadRequest) returns (PartitionResponse) {
    option (google.api.http) = {
      post: "/v1/{session=projects/*/instances/*/databases/*/sessions/*}:partitionRead"
      body: "*"
    };
  }
}

// omit ...
```

to

```go
// Code generated by protoc-gen-grpcproxy. DO NOT EDIT.

package spanner

import (
	context "context"
	errors "errors"
	grpc "google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	net "net"
)

var _ emptypb.Empty

// Proxy allows to create Spanner proxy servers.
type Proxy struct {
	BatchCreateSessions func(ctx context.Context, req *BatchCreateSessionsRequest) (*BatchCreateSessionsResponse, error)
	BeginTransaction    func(ctx context.Context, req *BeginTransactionRequest) (*Transaction, error)
	Commit              func(ctx context.Context, req *CommitRequest) (*CommitResponse, error)
	CreateSession       func(ctx context.Context, req *CreateSessionRequest) (*Session, error)
	DeleteSession       func(ctx context.Context, req *DeleteSessionRequest) (*emptypb.Empty, error)
	ExecuteBatchDml     func(ctx context.Context, req *ExecuteBatchDmlRequest) (*ExecuteBatchDmlResponse, error)
	ExecuteSql          func(ctx context.Context, req *ExecuteSqlRequest) (*ResultSet, error)
	ExecuteStreamingSql func(ctx context.Context, req *ExecuteSqlRequest) (*PartialResultSet, error)
	GetSession          func(ctx context.Context, req *GetSessionRequest) (*Session, error)
	ListSessions        func(ctx context.Context, req *ListSessionsRequest) (*ListSessionsResponse, error)
	PartitionQuery      func(ctx context.Context, req *PartitionQueryRequest) (*PartitionResponse, error)
	PartitionRead       func(ctx context.Context, req *PartitionReadRequest) (*PartitionResponse, error)
	Read                func(ctx context.Context, req *ReadRequest) (*ResultSet, error)
	Rollback            func(ctx context.Context, req *RollbackRequest) (*emptypb.Empty, error)
	StreamingRead       func(ctx context.Context, req *ReadRequest) (*PartialResultSet, error)
}

// Serve starts serving the proxy server on the given listener with the specified options.
func (p *Proxy) Serve(l net.Listener, opts ...grpc.ServerOption) error {
	srv := grpc.NewServer(opts...)
	RegisterSpannerServer(srv, &spannerServer{proxy: p})

	return srv.Serve(l)
}

var errNotSupported = errors.New("operation not supported")

type spannerServer struct {
	proxy *Proxy
}

func (s *spannerServer) BatchCreateSessions(ctx context.Context, req *BatchCreateSessionsRequest) (*BatchCreateSessionsResponse, error) {
	fn := s.proxy.BatchCreateSessions
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) BeginTransaction(ctx context.Context, req *BeginTransactionRequest) (*Transaction, error) {
	fn := s.proxy.BeginTransaction
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) Commit(ctx context.Context, req *CommitRequest) (*CommitResponse, error) {
	fn := s.proxy.Commit
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) CreateSession(ctx context.Context, req *CreateSessionRequest) (*Session, error) {
	fn := s.proxy.CreateSession
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) DeleteSession(ctx context.Context, req *DeleteSessionRequest) (*emptypb.Empty, error) {
	fn := s.proxy.DeleteSession
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) ExecuteBatchDml(ctx context.Context, req *ExecuteBatchDmlRequest) (*ExecuteBatchDmlResponse, error) {
	fn := s.proxy.ExecuteBatchDml
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) ExecuteSql(ctx context.Context, req *ExecuteSqlRequest) (*ResultSet, error) {
	fn := s.proxy.ExecuteSql
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) ExecuteStreamingSql(ctx context.Context, req *ExecuteSqlRequest) (*PartialResultSet, error) {
	fn := s.proxy.ExecuteStreamingSql
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) GetSession(ctx context.Context, req *GetSessionRequest) (*Session, error) {
	fn := s.proxy.GetSession
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) ListSessions(ctx context.Context, req *ListSessionsRequest) (*ListSessionsResponse, error) {
	fn := s.proxy.ListSessions
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) PartitionQuery(ctx context.Context, req *PartitionQueryRequest) (*PartitionResponse, error) {
	fn := s.proxy.PartitionQuery
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) PartitionRead(ctx context.Context, req *PartitionReadRequest) (*PartitionResponse, error) {
	fn := s.proxy.PartitionRead
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) Read(ctx context.Context, req *ReadRequest) (*ResultSet, error) {
	fn := s.proxy.Read
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) Rollback(ctx context.Context, req *RollbackRequest) (*emptypb.Empty, error) {
	fn := s.proxy.Rollback
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}

func (s *spannerServer) StreamingRead(ctx context.Context, req *ReadRequest) (*PartialResultSet, error) {
	fn := s.proxy.StreamingRead
	if fn == nil {
		return nil, errNotSupported
	}

	return fn(ctx, req)
}
```
