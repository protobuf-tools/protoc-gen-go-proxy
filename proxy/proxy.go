// SPDX-FileCopyrightText: Copyright 2022 The protobuf-tools Authors
// SPDX-License-Identifier: BSD-3-Clause

// Package proxy generates RPC service proxy.
package proxy

import (
	"cmp"
	"fmt"
	"path"
	"path/filepath"
	"slices"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
)

var version = "devel"

// list of _proxy.pb.go files package dependencies.
const (
	contextPackage = protogen.GoImportPath("context")
	errorsPackage  = protogen.GoImportPath("errors")
	netPackage     = protogen.GoImportPath("net")

	emptyPackage = protogen.GoImportPath("google.golang.org/protobuf/types/known/emptypb")
	grpcPackage  = protogen.GoImportPath("google.golang.org/grpc")
)

var pbPackage protogen.GoImportPath

// Config represents a protoc-gen-proxy config.
type Config struct {
	Standalone bool
}

// Method represents a generated RPC method.
type Method struct {
	GoName      string
	IsStreaming bool
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// GenerateFile generates RPC service proxy from .pb.go types.
func GenerateFile(p *protogen.Plugin, f *protogen.File, cfg *Config) *protogen.GeneratedFile {
	if len(f.Services) == 0 {
		return nil
	}

	filename := f.GeneratedFilenamePrefix + "_proxy.pb.go"
	goImportPath := f.GoImportPath
	if cfg.Standalone {
		goImportPath = protogen.GoImportPath(".") // dummy path for import pb package
	}

	g := p.NewGeneratedFile(filename, goImportPath)

	goPackageName := f.GoPackageName
	if cfg.Standalone {
		pbPackage = f.GoImportPath
		g.QualifiedGoIdent(pbPackage.Ident(""))
		goPackageName += "proxy"
	}

	g.P("// Code generated by protoc-gen-proxy. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-proxy ", version)
	g.P("// - protoc           ", protocVersion(p))
	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// Deprecated: ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
	g.P(`package `, goPackageName)
	g.P()
	g.P(`const (`)

	services := f.Services
	for i, service := range services {
		slices.SortFunc(services[i].Methods, func(x, y *protogen.Method) int {
			return cmp.Compare(x.GoName, y.GoName)
		})

		svcName := string("/" + service.Desc.FullName())
		for _, method := range service.Methods {
			fullMethod := path.Join(svcName, string(method.Desc.Name()))
			g.P(`	FullMethod`, method.GoName, ` = `, strconv.Quote(fullMethod))
		}
		g.P(`)`)

		serviceName := service.GoName
		methods := make(map[Method]string)
		idStr := pbPackage.String()
		importPath := filepath.Base(idStr[1 : len(idStr)-1])
		registerServerName := fmt.Sprintf("Register%sServer", serviceName)
		if cfg.Standalone {
			registerServerName = importPath + "." + registerServerName
		}

		for _, method := range service.Methods {
			mes := Method{
				GoName:      method.GoName,
				IsStreaming: method.Desc.IsStreamingServer(),
			}

			input := method.Input.GoIdent.GoName
			output := method.Output.GoIdent.GoName
			if cfg.Standalone {
				// handle emptypb
				if input != emptyPackage.Ident("Empty").GoName {
					input = g.QualifiedGoIdent(pbPackage.Ident(string(method.Input.GoIdent.GoName)))
				}
				if output != emptyPackage.Ident("Empty").GoName {
					output = g.QualifiedGoIdent(pbPackage.Ident(string(method.Output.GoIdent.GoName)))
				}
			}

			// handle emptypb
			if input == emptyPackage.Ident("Empty").GoName {
				input = g.QualifiedGoIdent(emptyPackage.Ident("Empty"))
			}
			if output == emptyPackage.Ident("Empty").GoName {
				output = g.QualifiedGoIdent(emptyPackage.Ident("Empty"))
			}

			args := fmt.Sprintf(`(ctx %s, req *%s) (*%s, error)`, g.QualifiedGoIdent(contextPackage.Ident("Context")), input, output)
			if cfg.Standalone && mes.IsStreaming {
				args = fmt.Sprintf(`(req *%s, srv %s_%sServer) error`, input, importPath+"."+serviceName, method.GoName)
			}
			methods[mes] = args
		}

		// sort RPC methods
		sortMethods := make([]Method, len(methods))
		i := 0
		for mes := range methods {
			sortMethods[i] = mes
			i++
		}
		slices.SortFunc(sortMethods, func(x, y Method) int {
			return cmp.Compare(x.GoName, y.GoName)
		})

		serverName := "proxyServer"
		g.P(`var ErrNotSupported = `, g.QualifiedGoIdent(errorsPackage.Ident("New")), `("operation not supported")`)
		g.P()
		g.P(`type `, serverName, ` struct {`)
		g.P(`	proxy *Proxy`)
		g.P(`}`)
		g.P()
		for _, mes := range sortMethods {
			args := methods[mes]

			ret := `fn(ctx, req)`
			retErr := `nil, ErrNotSupported`
			if mes.IsStreaming {
				ret = `fn(req, srv)`
				retErr = `ErrNotSupported`
			}
			g.P(`func (s *`, serverName, `) `, mes.GoName, args, ` {`)
			g.P(`	fn := s.proxy.`, mes.GoName)
			g.P(` 	if fn == nil {`)
			g.P(` 		return `, retErr)
			g.P(` 	}`)
			g.P()
			g.P(`return `, ret)
			g.P(`}`)
			g.P()
		}
		g.P()
		g.P(`// Proxy allows to create `, serviceName, ` proxy servers.`)
		g.P(`type Proxy struct {`)
		for _, mes := range sortMethods {
			args := methods[mes]
			g.P(`	`, mes.GoName, ` func`, args)
		}
		g.P(`}`)
		g.P()
		g.P(`// Serve starts serving the proxy server on the given listener with the specified options.`)
		g.P(`func (p *Proxy) Serve(l `, g.QualifiedGoIdent(netPackage.Ident("Listener")), `, opts ...grpc.ServerOption) error {`)
		g.P(`	srv := `, g.QualifiedGoIdent(grpcPackage.Ident("NewServer")), `(opts...)`)
		g.P(`	`, registerServerName, `(srv, &`, serverName, `{proxy: p})`)
		g.P()
		g.P(`	return srv.Serve(l)`)
		g.P(`}`)
	}

	return g
}
