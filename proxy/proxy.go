// SPDX-FileCopyrightText: Copyright 2022 The protobuf-tools Authors
// SPDX-License-Identifier: BSD-3-Clause

// Package proxy generates RPC service proxy.
package proxy

import (
	"cmp"
	"fmt"
	"path/filepath"
	"slices"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

var version = "devel"

// List of _grpc.proxy.pb.go files package dependencies.
const (
	contextPackage = protogen.GoImportPath("context")
	netPackage     = protogen.GoImportPath("net")

	gRPCPackage    = protogen.GoImportPath("google.golang.org/grpc")
	codesPackage   = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage  = protogen.GoImportPath("google.golang.org/grpc/status")
	emptypbPackage = protogen.GoImportPath("google.golang.org/protobuf/types/known/emptypb")
)

var pbPackage protogen.GoImportPath

// Config represents a protoc-gen-grpcproxy config.
type Config struct {
	Standalone bool
}

// Method represents a generated RPC method.
type Method struct {
	GoName            string
	IsStreamingClient bool
	IsStreamingServer bool
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}

	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}

	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

// GenerateFile generates RPC service proxy from .pb.go types.
func GenerateFile(p *protogen.Plugin, f *protogen.File, cfg *Config) *protogen.GeneratedFile {
	if len(f.Services) == 0 {
		return nil
	}

	filename := f.GeneratedFilenamePrefix + "_grpc.proxy.pb.go"
	goImportPath := f.GoImportPath
	if cfg.Standalone {
		goImportPath = protogen.GoImportPath(".") // dummy path for import pb package
	}

	g := p.NewGeneratedFile(filename, goImportPath)

	goPackageName := f.GoPackageName
	if cfg.Standalone {
		pbPackage = f.GoImportPath
		g.QualifiedGoIdent(pbPackage.Ident(""))
		goPackageName += "proxy"
	}

	g.P("// Code generated by protoc-gen-grpcproxy. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-grpcproxy ", version)
	g.P("// - protoc           ", protocVersion(p))
	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// Deprecated: ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
	g.P(`package `, goPackageName)
	g.P()

	services := f.Services
	for i, service := range services {
		slices.SortFunc(services[i].Methods, func(x, y *protogen.Method) int {
			return cmp.Compare(x.GoName, y.GoName)
		})

		serviceName := service.GoName
		methods := make(map[Method]string)
		idStr := pbPackage.String()
		importPath := filepath.Base(idStr[1 : len(idStr)-1])
		registerServerName := fmt.Sprintf("Register%sServer", serviceName)
		if cfg.Standalone {
			registerServerName = importPath + "." + registerServerName
		}

		for _, method := range service.Methods {
			mes := Method{
				GoName:            method.GoName,
				IsStreamingClient: method.Desc.IsStreamingClient(),
				IsStreamingServer: method.Desc.IsStreamingServer(),
			}

			input := method.Input.GoIdent.GoName
			output := method.Output.GoIdent.GoName
			if cfg.Standalone {
				// handle emptypb
				if input != emptypbPackage.Ident("Empty").GoName {
					input = g.QualifiedGoIdent(pbPackage.Ident(string(method.Input.GoIdent.GoName)))
				}
				if output != emptypbPackage.Ident("Empty").GoName {
					output = g.QualifiedGoIdent(pbPackage.Ident(string(method.Output.GoIdent.GoName)))
				}
			}

			// handle emptypb
			if input == emptypbPackage.Ident("Empty").GoName {
				input = g.QualifiedGoIdent(emptypbPackage.Ident("Empty"))
			}
			if output == emptypbPackage.Ident("Empty").GoName {
				output = g.QualifiedGoIdent(emptypbPackage.Ident("Empty"))
			}

			var args string
			switch {
			case mes.IsStreamingClient:
				srvName := serviceName
				if cfg.Standalone {
					srvName = importPath + "." + serviceName
				}
				args = fmt.Sprintf(`(srv %s_%sServer) error`, srvName, method.GoName)
			case mes.IsStreamingServer:
				srvName := serviceName
				if cfg.Standalone {
					srvName = importPath + "." + serviceName
				}
				args = fmt.Sprintf(`(req *%s, srv %s_%sServer) error`, input, srvName, method.GoName)
			default:
				args = fmt.Sprintf(`(ctx %s, req *%s) (*%s, error)`, g.QualifiedGoIdent(contextPackage.Ident("Context")), input, output)
			}
			methods[mes] = args
		}

		// sort RPC methods
		sortMethods := make([]Method, len(methods))
		i := 0
		for mes := range methods {
			sortMethods[i] = mes
			i++
		}
		slices.SortFunc(sortMethods, func(x, y Method) int {
			return cmp.Compare(x.GoName, y.GoName)
		})

		lowerServiceName := string(unicode.ToLower(rune(serviceName[0]))) + serviceName[1:]
		proxyServer := lowerServiceName + "Proxy"
		g.P(`type `, proxyServer, ` struct {`)
		g.P(`	proxy *`, serviceName, `Proxy`)
		g.P(`}`)
		g.P()

		statusErrorf := g.QualifiedGoIdent(statusPackage.Ident("Errorf"))
		codesUnimplemented := g.QualifiedGoIdent(codesPackage.Ident("Unimplemented"))
		for _, mes := range sortMethods {
			args := methods[mes]

			unimplemented := fmt.Sprintf(`%s(%s, "method %s not implemented")`, statusErrorf, codesUnimplemented, mes.GoName)
			var ret, retErr string
			switch {
			case mes.IsStreamingClient:
				ret = `fn(srv)`
				retErr = unimplemented
			case mes.IsStreamingServer:
				ret = `fn(req, srv)`
				retErr = unimplemented
			default:
				ret = `fn(ctx, req)`
				retErr = `nil, ` + unimplemented
			}

			g.P(`func (s *`, proxyServer, `) `, mes.GoName, args, ` {`)
			g.P(`	fn := s.proxy.`, mes.GoName)
			g.P(` 	if fn == nil {`)
			g.P(` 		return `, retErr)
			g.P(` 	}`)
			g.P()
			g.P(`return `, ret)
			g.P(`}`)
			g.P()
		}
		g.P()

		proxyType := serviceName + `Proxy`
		g.P(`// `, proxyType, ` allows to create `, serviceName, ` proxy.`)
		g.P(`type `, proxyType, ` struct {`)
		for _, mes := range sortMethods {
			args := methods[mes]
			g.P(`	`, mes.GoName, ` func`, args)
		}
		g.P(`}`)
		g.P()

		netListener := g.QualifiedGoIdent(netPackage.Ident("Listener"))
		gRPCServerOption := g.QualifiedGoIdent(gRPCPackage.Ident("ServerOption"))
		g.P(`// Serve starts serving the proxy server on the given [`, netListener, `] with the specified options.`)
		g.P(`func (p *`, serviceName, `Proxy) Serve(l `, netListener, `, opts ...`, gRPCServerOption, `) error {`)
		g.P(`	srv := `, g.QualifiedGoIdent(gRPCPackage.Ident("NewServer")), `(opts...)`)
		g.P(`	`, registerServerName, `(srv, &`, proxyServer, `{proxy: p})`)
		g.P()
		g.P(`	return srv.Serve(l)`)
		g.P(`}`)
	}

	return g
}
